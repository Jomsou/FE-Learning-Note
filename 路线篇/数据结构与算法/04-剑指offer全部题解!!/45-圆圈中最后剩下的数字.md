## 题目描述

    六一儿童节快要到了,牛妹为小伙伴们准备了一个小游戏，学会了可以将一堆小盆友驯（调）服（教）成功噢~
    第一步：你需要准备一堆小礼品，其中一份一定是所有小盆友都喜欢的，这个你懂哒~；
    第二步：让小盆友们围成一个大圈，你随机指定一个数m，让编号为1的小盆友开始报数；
    第三步：规定每次喊到m的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，
    并且不再回到圈中，从他的下一个小朋友开始，继续1...m报数....这样下去....直到剩下最后一个小朋友，
    可以不用表演并且拿到最受欢迎的小礼品，至此小游戏结束；
    那么问题来了，你如何才能把最受欢迎的小礼品光（悄）明（声）大（息）的送给你最喜欢的小盆友呢？

## 解法

    找规律。首先定义最初的n个数字（0,1,…,n-1）中最后剩下的数字是关于n和m的方程为f(n,m)。
    在这n个数字中，第一个被删除的数字是（m-1）%n，为简单起见记为k。
    那么删除k之后的剩下n-1的数字为0,1,…,k-1,k+1,…,n-1，并且下一个开始计数的数字是k+1。
    相当于在剩下的序列中，k+1排到最前面，从而形成序列k+1,…,n-1,0,…k-1。
    该序列最后剩下的数字也应该是关于n和m的函数。由于这个序列的规律和前面最初的序列不一样
    （最初的序列是从0开始的连续序列），因此该函数不同于前面函数，记为f’(n-1,m)。
    最初序列最后剩下的数字f(n,m)一定是剩下序列的最后剩下数字f’(n-1,m)，所以f(n,m)=f’(n-1,m)。
    接下来我们把剩下的的这n-1个数字的序列k+1,…,n-1,0,…k-1作一个映射，映射的结果是形成一个从0到n-2的序列：
    k+1    ->    0
    k+2    ->    1
    …
    n-1    ->    n-k-2
    0      ->    n-k-1
    …
    k-1    ->    n-2
    把映射定义为p，则p(x)= (x-k-1)%n，即如果映射前的数字是x，则映射后的数字是(x-k-1)%n。
    对应的逆映射是p-1(x)=(x+k+1)%n。由于映射之后的序列和最初的序列有同样的形式，
    都是从0开始的连续序列，因此仍然可以用函数f来表示，记为f(n-1,m)。
    根据我们的映射规则，映射之前的序列最后剩下的数字f’(n-1,m)= p-1 [f(n-1,m)]=[f(n-1,m)+k+1]%n。
    把k=m%n-1代入得到f(n,m)=f’(n-1,m)=[f(n-1,m)+m]%n。
    
    经过上面复杂的分析，我们终于找到一个递归的公式。要得到n个数字的序列的最后剩下的数字，
    只需要得到n-1个数字的序列的最后剩下的数字，并可以依此类推。
    当n=1时，也就是序列中开始只有一个数字0，那么很显然最后剩下的数字就是0。我们把这种关系表示为：
               0                            n=1
    f(n,m)={
              [f(n-1,m)+m]%n     n>1
    尽管得到这个公式的分析过程非常复杂，但它用递归或者循环都很容易实现。
    最重要的是，这是一种时间复杂度为O(n)，空间复杂度为O(1)的方法，
    因此无论在时间上还是空间上都优于前面的思路。
    
    
## java

    public class Solution {  
        public int LastRemaining_Solution(int n,int m) {  
            if(n==0) return -1;  
              
           int s=0;  
           for(int i=2;i<=n;i++){  
               s=(s+m)%i;  
           }  
           return s;  
        }  
    }  