一、实现冒泡排序

这是排序算法的第一个挑战。给定一个未排序的数组，然后经过排序返回一个有顺序的数组。在接下来的算法挑战中,我们将通过几种不同的方法来实现排序，并在这些不同的方法之间学习一些权衡。虽然大多数现代语言都有内置的这种操作的排序方法，但仍然需要了解一些常见的基本方法，并了解如何实现它们。

冒泡排序

在这里我们将看到冒泡排序。冒泡排序通过重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

该方法需要通过数组进行多次迭代，平均和最差情况下都具有二次时间复杂度。

下面我们来举例说明一下冒泡排序

整形数组未排序前的顺序如下:

[42,20,17,13,28,14,23,15]

第一趟排序,我们从后一个元素15开始,不断与之相邻的元素进行比较,如果比15大,则交换位置,如果比15小,就交换比较元素,第一趟之后,我们得到数组里的最小元素13,而且13也位于数组的第一个元素了,通过不断的排序比较,在比较了数组长度-1次以后,该数组的所有元素已经根据大小排好顺序了

![](./images/002.png)

任务：写一个函数bubbleSort，它将下列整型数组作为输入，并返回一个排列好的整形数组。

[1,4,2,8,345,123,43,32,5643,63,123,43,2,55,1,234,92]

```
// helper function to generate a randomly filled array
var array = [];
(function createArray(size) {
  array.push(+(Math.random() * 100).toFixed(0));
  return (size > 1) ? createArray(size - 1) : undefined;
})(12);

function bubbleSort(array) {
  // change code below this line

  // change code above this line
  return array;
}
```
